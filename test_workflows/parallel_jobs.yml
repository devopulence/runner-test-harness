name: Parallel Jobs Capacity Test

on:
  workflow_dispatch:
    inputs:
      test_id:
        description: 'Unique test identifier'
        required: true
        type: string
      job_count:
        description: 'Number of parallel jobs to run'
        required: false
        default: '5'
        type: string
      job_duration:
        description: 'Duration of each job in seconds'
        required: false
        default: '30'
        type: string

jobs:
  generate-matrix:
    runs-on: ubuntu-latest
    name: Generate Matrix - ${{ inputs.test_id }}
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      start_time: ${{ steps.timer.outputs.start_time }}

    steps:
      - name: ðŸ“ Test Configuration
        run: |
          echo "Parallel Jobs Test Configuration"
          echo "================================"
          echo "Test ID: ${{ inputs.test_id }}"
          echo "Job Count: ${{ inputs.job_count }}"
          echo "Job Duration: ${{ inputs.job_duration }}s"

      - name: â±ï¸ Start Timer
        id: timer
        run: |
          echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

      - name: ðŸ”¢ Generate Job Matrix
        id: set-matrix
        run: |
          matrix=$(seq 1 ${{ inputs.job_count }} | jq -R . | jq -s -c '{job_id: .}')
          echo "matrix=${matrix}" >> $GITHUB_OUTPUT
          echo "Generated matrix for ${{ inputs.job_count }} parallel jobs"

  parallel-job:
    needs: generate-matrix
    runs-on: ubuntu-latest
    name: Job ${{ matrix.job_id }}/${{ inputs.job_count }}
    strategy:
      matrix: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
      max-parallel: 50  # GitHub's max is typically 256, but we set a reasonable limit
      fail-fast: false  # Continue other jobs even if one fails

    steps:
      - name: ðŸš€ Job Start
        run: |
          echo "Starting Job ${{ matrix.job_id }} at $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "JOB_START=$(date +%s)" >> $GITHUB_ENV

      - name: ðŸ“Š Initial Metrics
        run: |
          echo "Collecting initial metrics..."
          echo "Job ID: ${{ matrix.job_id }}"
          echo "Runner: ${{ runner.name }}"
          echo "OS: ${{ runner.os }}"
          echo "Arch: ${{ runner.arch }}"

          # System info
          echo "CPU Info:"
          nproc
          cat /proc/cpuinfo | grep "model name" | head -1

          echo "Memory Info:"
          free -h

      - name: ðŸ”„ Workload Simulation
        run: |
          echo "Executing workload for ${{ inputs.job_duration }} seconds..."

          # Variable workload based on job ID
          WORKLOAD_TYPE=$(((${{ matrix.job_id }} - 1) % 3))

          case $WORKLOAD_TYPE in
            0)
              echo "Job ${{ matrix.job_id }}: CPU-intensive workload"
              # CPU benchmark
              timeout ${{ inputs.job_duration }}s bash -c '
                while true; do
                  echo "scale=5000; 4*a(1)" | bc -l > /dev/null
                done
              ' || true
              ;;
            1)
              echo "Job ${{ matrix.job_id }}: I/O-intensive workload"
              # I/O operations
              timeout ${{ inputs.job_duration }}s bash -c '
                while true; do
                  dd if=/dev/urandom of=/tmp/testfile bs=1M count=10 2>/dev/null
                  rm -f /tmp/testfile
                done
              ' || true
              ;;
            2)
              echo "Job ${{ matrix.job_id }}: Mixed workload"
              # Mixed operations
              sleep ${{ inputs.job_duration }}
              ;;
          esac

      - name: ðŸ“ˆ Performance Metrics
        run: |
          JOB_END=$(date +%s)
          JOB_DURATION=$((JOB_END - JOB_START))

          # Create metrics file
          cat << EOF > metrics_${{ matrix.job_id }}.json
          {
            "job_id": "${{ matrix.job_id }}",
            "test_id": "${{ inputs.test_id }}",
            "requested_duration": ${{ inputs.job_duration }},
            "actual_duration": ${JOB_DURATION},
            "start_time": "${JOB_START}",
            "end_time": "${JOB_END}",
            "runner_os": "${{ runner.os }}",
            "status": "completed"
          }
          EOF

          cat metrics_${{ matrix.job_id }}.json

      - name: ðŸ“¤ Save Job Metrics
        uses: actions/upload-artifact@v3
        with:
          name: parallel-metrics-${{ inputs.test_id }}
          path: metrics_${{ matrix.job_id }}.json
          retention-days: 1

      - name: âœ… Job Complete
        run: |
          echo "Job ${{ matrix.job_id }} completed successfully"
          echo "Duration: ${JOB_DURATION}s"

  analyze-parallelism:
    needs: [generate-matrix, parallel-job]
    runs-on: ubuntu-latest
    name: Analyze Parallelism - ${{ inputs.test_id }}
    if: always()  # Run even if some parallel jobs fail

    steps:
      - name: ðŸ“¥ Download Metrics
        uses: actions/download-artifact@v3
        with:
          name: parallel-metrics-${{ inputs.test_id }}
          path: ./metrics

      - name: ðŸ“Š Analyze Results
        run: |
          echo "Analyzing parallel execution results..."

          # Count successful jobs
          COMPLETED_JOBS=$(ls -1 metrics/metrics_*.json 2>/dev/null | wc -l || echo 0)
          echo "Completed jobs: ${COMPLETED_JOBS}/${{ inputs.job_count }}"

          if [ ${COMPLETED_JOBS} -gt 0 ]; then
            # Combine all metrics
            jq -s '.' metrics/metrics_*.json > combined_metrics.json

            # Calculate statistics
            echo "Calculating execution statistics..."

            # Find min/max start times to determine actual parallelism
            MIN_START=$(jq '[.[].start_time | tonumber] | min' combined_metrics.json)
            MAX_START=$(jq '[.[].start_time | tonumber] | max' combined_metrics.json)
            MIN_END=$(jq '[.[].end_time | tonumber] | min' combined_metrics.json)
            MAX_END=$(jq '[.[].end_time | tonumber] | max' combined_metrics.json)

            SPREAD=$((MAX_START - MIN_START))
            TOTAL_TIME=$((MAX_END - MIN_START))

            echo "Job start time spread: ${SPREAD} seconds"
            echo "Total execution time: ${TOTAL_TIME} seconds"

            # Estimate parallelism
            if [ ${SPREAD} -lt 10 ]; then
              echo "High parallelism: All jobs started within ${SPREAD} seconds"
            elif [ ${SPREAD} -lt 30 ]; then
              echo "Moderate parallelism: Jobs started within ${SPREAD} seconds"
            else
              echo "Limited parallelism: Job starts spread over ${SPREAD} seconds"
            fi
          else
            echo "No metrics files found"
          fi

      - name: ðŸ“‘ Generate Summary Report
        run: |
          TEST_END=$(date +%s)
          TEST_START=${{ needs.generate-matrix.outputs.start_time }}
          TOTAL_DURATION=$((TEST_END - TEST_START))

          cat << EOF > parallelism_report.json
          {
            "test_id": "${{ inputs.test_id }}",
            "test_type": "parallel_jobs",
            "configuration": {
              "requested_jobs": ${{ inputs.job_count }},
              "job_duration": ${{ inputs.job_duration }}
            },
            "results": {
              "completed_jobs": ${COMPLETED_JOBS:-0},
              "total_test_duration": ${TOTAL_DURATION},
              "theoretical_minimum": ${{ inputs.job_duration }},
              "parallelism_efficiency": $(echo "scale=2; ${{ inputs.job_duration }} * 100 / ${TOTAL_DURATION}" | bc)
            },
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF

          echo "===== PARALLELISM TEST REPORT ====="
          cat parallelism_report.json | jq '.'

      - name: ðŸ“¤ Upload Final Report
        uses: actions/upload-artifact@v3
        with:
          name: parallelism-report-${{ inputs.test_id }}
          path: |
            parallelism_report.json
            combined_metrics.json

      - name: âœ… Analysis Complete
        run: |
          echo "========================================="
          echo "PARALLEL JOBS TEST COMPLETED"
          echo "========================================="
          echo "Test ID: ${{ inputs.test_id }}"
          echo "Jobs Requested: ${{ inputs.job_count }}"
          echo "Jobs Completed: ${COMPLETED_JOBS:-0}"
          echo "Total Duration: ${TOTAL_DURATION}s"
          echo "========================================="